<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>事件循环机制</title>
</head>
<body>
    


    <script>
        
        //事件循环机制 [JavaScript是一门单线程语言]
        // 前言: JavaScript的另一个特点是非阻塞,那么JavaScript是如何实现这一点的呢? 答案就是今天的主角---event loop(事件循环)

        //1. JavaScript代码执行的时候会讲不同的变量存与内存中的不同位置
            // 堆(heap)： 堆里面存放一些对象
            // 栈(stack): 存放基础类型变量及指针

            // 栈内存                          堆内存
            //
            //a   12345                         Object
            //b   'asdasd'                      object
            //c    null                             
            //d    指针
            //e    undefined                Object
            //f    true
            //.      .
            //.      .
            //.      .

        //2. 执行栈与事件队列
        // 执行栈: 当我们调用一个方法的时候,js会生成一个与之对应的执行环境（当这个执行环境中的代码执行完毕后,js会退出这个执行环境并把这个执行环境销毁）,又叫执行上下文.这个执行上下文环境中
                //存在着这个方法的:
                //                 私有作用域
                //                 上层作用域的指向(作用域链)
                //                 方法的参数
                //                 这个作用与定义的变量
                //                 这个作用域的this对象
            //而当一系列方法被调用的时候,因为js是单线程的,同一时间只能执行一个方法,于是这些方法排队在一个单独的地方
            //这个地方被称之为 执行栈.

        //注: 以上代码是同步代码的执行,那么当一个异步代码执行后会如何呢? 前文提过.js零一大特点就是非阻塞,实现这一点关键在与下面要说的这项机制----事件队列

        // 事件队列: js引擎遇到一个异步事件后并不会一直等待其返回结果,而是会将这个事件挂起,继续执行执行栈中的其他任务,当一个异步事件
                 //放回结果后,js会将这个事件加入当前执行栈中的另一个队列,我们称之为 事件队列.被放入事件队列不会立即执行回调,而是等待当前执行栈中的所有任务
                 //执行完毕,主线程处于闲置状态时,主线程会去查找事件队列是否有任务,如果有,那么主线程会从中取出排在第一位的事件,并把这个事件对应的回调放入执行栈中
                 //然后执行其中的同步代码,如此反复,这样就形成了一个无线循环, 这个过程被称为事件循环.

    </script>

</body>
</html>